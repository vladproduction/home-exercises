Приведенная выше программа создает множество объектов Chair, и в некоторой точке, после начала
работы сборщика мусора, программа прекращает создание Chair. Так как сборщик мусора может
запуститься в любой момент, вы не можете точно знать, когда он стартует, поэтому есть флаг,
называемый gcrun для индикации того, произошел ли запуск сборщика мусора. Второй флаг f дает
возможность объекту Chair сообщить в цикл main( ), что он должен остановить создание объектов.
Оба эти флага устанавливаются в finalize( ), который вызывается при сборке мусора.

Две другие static переменные: created и finalized, следят за числом созданных Chair и за числом
объектов, подвергшихся финализации сборщиком мусора. И, наконец, каждый Chair имеет свой собственный
(не-static) int i, который следит за тем, какой порядковый номер имеет объект. Когда финилизируется
Chair с номером 47, флаг устанавливается в true, чтобы инициировать остановку процесса создания Chair.

Все это происходит в цикле main( )

    while(!Chair.f) {
      new Chair();
      new String("To take up space");
    }
Вы можете удивиться, как этот цикл вообще может завершиться, так как внутри нет ничего, что изменяло
бы значение Chair.f. Однако finalize( ), в конечном счете, сделает это, когда будет финализован объект
номер 47.

Создание объекта String в каждой итерации просто приводит к дополнительному выделению места для
ускорения запуска сборщика мусора, который начнет действовать, когда будет озабочен количеством
доступной памяти.

Когда вы запускаете программу, вы передаете аргумент командной строки “gc,” “finalize,” или “all”.
Аргумент “gc” приведет к вызову метода System.gc( ) (для форсирования работы сборщика мусора).
Использование “finalize” приведет к вызову System.runFinalization( ), который, теоретически, является
причиной того, что не финализированные объекты будут финализированы. А “all” станет причиной вызова
обоих методов.